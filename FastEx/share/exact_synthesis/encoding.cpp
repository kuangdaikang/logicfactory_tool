//
// Created by zephyr on 2023/2/18.
//
#include "exact.h"
#include <fstream>
#include <sstream>

exact::Encoding::Encoding(const std::string &file_name) : num_variables_in_real(0), num_clauses_in_real(0) {
    std::ifstream fin(file_name);
    assert(fin.is_open());
    std::string temp;
    while (getline(fin, temp)) {
        if (temp[0] == 'c')
            comments.emplace_back(temp);
        else if (temp[0] == 'p') {
            std::stringstream sin(temp);
            std::string _temp;
            sin >> _temp >> temp;
            sin >> num_variables >> num_clauses;
        } else {
            std::stringstream sin(temp);
            std::vector<int> clause;
            int _temp;
            while (sin >> _temp) {
                if (_temp == 0)
                    break;
                else
                    clause.emplace_back(_temp);
            }
            clauses.emplace_back(clause);
        }
    }
}

bool exact::Encoding::verify(std::vector<bool> assignment) {
    bool flag = true;
    for (auto &clause: clauses) {
        bool temp = false;
        for (auto &variable: clause) {
            bool inv = variable < 0;
            int index = abs(variable);
            temp = temp || (inv ? !assignment[index] : assignment[index]);
        }
        if (!temp) {
            for (auto &variable: clause) {
                std::cout << variable << " ";
            }
            std::cout << std::endl;
            flag = false;
        }
    }
    return flag;
}

bool exact::Encoding::check() {
    std::vector<int> temp(num_variables + 1, 0);
    for (const auto &clause: clauses) {

        for (auto variable: clause) {
            variable = variable < 0 ? -variable : variable;
            if (variable > num_variables || variable == 0) {
                return false;
            }
            temp[variable]++;
        }
    }
    for (int i = 1; i < num_variables; i++) {
        if (temp[i] == 0) {
            return false;
        }
    }
    return true;
}

void exact::Encoding::add_clause(const std::vector<int> &clause, bool no_check) {
    if (!no_check) {
        for (auto &variable: clause)
            assert(abs(variable) <= num_variables && variable != 0);
    } else {
        for (auto &variable: clause)
            num_variables = std::max(num_variables, variable);
    }
    clauses.emplace_back(clause);
    num_clauses++;
}

void exact::Encoding::write_dimacs(std::ostream &out) {
    out << "c dimacs generated by FastEx\n";
    for (auto &comment: comments)
        out << comment;
    out << "p cnf " << num_variables << " " << num_clauses << std::endl;
    for (auto &clause: clauses) {
        for (auto &variable: clause) {
            out << variable << " ";
        }
        out << "0\n";
    }
}

void exact::Encoding::add_comment(const std::string &comment) {
    comments.emplace_back(comment);
}

void exact::Encoding::write_smt2(std::ostream &out, bool keep_result = true) {
    for (auto &entry: comments)
        out << ";" << entry;

    if (keep_result)out << "(set-option :produce-models true)\n";
    out << "(set-logic NRA)\n";

    for (int i = 1; i <= num_variables; i++) {
        out << "(declare-fun v" << i << " () Bool)\n";
    }
    for (auto &clause: clauses) {
        out << "(assert (or ";
        for (auto &variable: clause) {
            if (variable < 0)
                out << "(not v" << -variable << ") ";
            else out << "v" << variable << " ";
        }
        out << "))\n";
    }

    for (int i = 1; i <= num_variables_in_real; i++) {
        out << "(declare-fun r" << i << " () Real)\n";
    }
    out << "(declare-fun r () Real)\n";
    for (auto &clause: clauses_in_real) {
        out << clause << "\n";
    }

    out << "(check-sat)\n";
    if (keep_result)out << "(get-value (";
    for (int i = 1; i <= num_variables; i++) {
        out << "v" << i << " ";
    }
    out << "))\n";
    //uncomment above line to print needed variables.
}

