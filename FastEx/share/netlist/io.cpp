//
// Created by zephyr on 2022/10/27.
//
#include "netlist.h"
#include "../utility/utility.h"

std::string filter_string(const std::string &str, std::vector<char> dic) {
    std::string new_str;
    for (auto &ch: str) {
        if (std::find(dic.begin(), dic.end(), ch) != dic.end())
            continue;
        else
            new_str += ch;
    }
    return new_str;
}

void NET::read_blif(const std::string &file, Netlist &netlist) {
    // If clear flag is set, redundant edges will be removed automatically
    std::ifstream fin(file, std::ios::in);
    assert(fin.is_open());

    // Clear existing netlist
    if (!netlist.nodes.empty()) {
        netlist = Netlist();
    }

    char temp_char;
    std::string temp_str;
    while (std::getline(fin, temp_str)) {
        //std::cout<<temp_str<<"\n";
        if (temp_str[0] == '#' || temp_str.empty())
            continue;
        while (temp_str[temp_str.length() - 1] == '\\') {
            temp_str = temp_str.substr(0, temp_str.length() - 1);
            std::string _temp_str;
            std::getline(fin, _temp_str);
            temp_str += _temp_str;
        }
        std::vector<std::string> str = split(temp_str);
        if (str[0] == ".model")
            netlist.name = str[1];
        else if (str[0] == ".end")
            continue;
        else if (str[0] == ".inputs") {
            for (auto it = str.begin() + 1; it != str.end(); it++) {
                Node *node = new Node(*it);
                node->outputs.emplace_back(std::vector<std::string>());
                node->num_fanout.emplace_back(0);
                node->min_depth = 1;
                node->max_depth = 1;
                node->signal_probability[0] = 0.5; // Warning: example value
                node->functions = std::vector<Function>(1, Function());
                netlist.add_node(node);
                netlist.inputs.emplace_back(node);
            }
        } else if (str[0] == ".outputs") {
            for (auto it = str.begin() + 1; it != str.end(); it++) {
                Node *node = new Node(*it);
                node->outputs.emplace_back(std::vector<std::string>());
                node->num_fanout.emplace_back(0);
                netlist.add_node(node);
                netlist.outputs.emplace_back(node);
            }
        } else if (str[0] == ".names") {
            std::string function;
            while (true) {
                fin >> temp_char;
                fin.putback(temp_char);
                if (temp_char == '.')
                    break;
                else {
                    std::string _temp_str;
                    std::getline(fin, _temp_str);
                    if (!function.empty())
                        function += "\n";
                    function += _temp_str;
                }
            }

            int num_inputs = int(str.size()) - 2;
            for (auto it = str.begin() + 1; it != str.end() - 1; it++) {
                auto input = netlist.has_node(*it);
                if (input != nullptr) {
                    (input->num_fanout[0])++;
                    input->outputs[0].emplace_back(*(split(*(str.end() - 1), '=').end() - 1));
                } else {
                    Node *node = new Node(*it);
                    node->outputs.emplace_back(std::vector<std::string>(1, *(split(*(str.end() - 1), '=').end() - 1)));
                    node->num_fanout[0]++;
                    netlist.add_node(node);
                }
            }
            auto node = netlist.has_node(*(str.end() - 1));
            if (node != nullptr) {
                node->num_fanin = num_inputs;
                node->inputs = std::vector<std::string>(str.begin() + 1, str.end() - 1);
                node->functions = std::vector<Function>(1, Function(num_inputs, function));
            } else {
                node = new Node(*(str.end() - 1), num_inputs, std::vector<unsigned int>(1, 0),
                                std::vector<std::string>(str.begin() + 1, str.end() - 1),
                                std::vector<Function>(1, Function(num_inputs, function)), std::vector<double>{-1});
                netlist.add_node(node);
            }
            for (auto it = str.begin() + 1; it != str.end() - 1; it++)
                netlist.edges.emplace_back(new Edge(netlist.has_node(*it), node));
        } else {
            std::cout << "Not implemented error";
            assert(false);
        }
    }
}

void NET::write_blif(const std::string &file, Netlist &netlist) {
    std::ofstream fout(file);
    assert(fout.is_open());
    fout << "# Generated by Exact Synthesis Project zephyr." << std::endl;
    //fout << ".model " << netlist.name << std::endl;
    fout << ".model top" << std::endl;
    fout << ".inputs";
    for (auto &input: netlist.inputs) {
        fout << " " << input->name;
    }
    fout << std::endl;
    fout << ".outputs";
    for (auto &output: netlist.outputs) {
        fout << " " << output->name;
    }
    fout << std::endl;
    for (auto &node: netlist.nodes) {
        if (node->functions[0].function.empty())
            continue;
        fout << ".names";
        for (auto &input: node->inputs)
            fout << " " << input;
        fout << " " << node->name << std::endl;
        // NOTE: do not support dual output.
        assert(node->functions.size() <= 1);

        for (auto &function: node->functions[0].function) {
            for (auto &input: function.first) {
                if (input == 1) fout << 1;
                else if (input == 0) fout << 0;
                else if (input == -1) fout << "-";
                else
                    assert(false);
            }
            fout << (function.first.empty() ? "" : " ") << (function.second ? 1 : 0) << std::endl;
        }
    }
    fout.close();
}

void NET::read_netlist_library(const std::string &library_file,
                               std::map<std::pair<std::string, std::string>, Netlist *> &library) {
    std::ifstream fin(library_file);
    assert(fin.is_open());

    //std::map<std::pair<std::string, std::string>, NET::Netlist> library;

    int type, num_mark, num_inputs, num_netlists;
    std::vector<std::string> additional_mark;
    std::string temp;
    while (getline(fin, temp)) {
        if (temp[0] == '#') {
            continue;
        } else if (temp[0] == 'T') {
            std::stringstream sin(temp);
            std::string _temp;
            sin >> _temp >> type;
            assert(type == 1 || type == 2);
        } else if (temp[0] == 'A') {
            std::stringstream sin(temp);
            std::string _temp;
            if (type == 2) {
                sin >> _temp >> num_mark >> _temp;
                additional_mark.emplace_back(_temp);
            }
        } else if (temp[0] == 'S') {
            std::stringstream sin(temp);
            std::string _temp;
            sin >> _temp >> num_netlists >> num_inputs;
        } else if (temp[0] == 'E') {
            break;
        } else if (temp[0] == '0' && (temp[1] == 'x' || temp[1] == 'X')) {
            //std::cout<<temp;
            int num_nodes, output_node_index;
            std::string truth_table, label;
            char temp_ch;
            std::stringstream sin(temp);
            sin >> temp_ch >> temp_ch >> truth_table >> label >> num_nodes;
            Netlist *netlist = new Netlist;
            netlist->name = "o_n_" + truth_table + label;

            // Add primary inputs
            for (int i = 1; i <= num_inputs; i++) {
                std::string node_name = "n_" + std::to_string(i);
                Node *node = new Node(node_name);
                node->outputs.emplace_back(std::vector<std::string>());
                node->num_fanout.emplace_back(0);
                node->min_depth = 1;
                node->max_depth = 1;
                node->functions = std::vector<Function>(1, Function());
                netlist->add_node(node);
                netlist->inputs.emplace_back(node);
            }

            for (int i = 0; i < num_nodes; i++) {
                std::string node_name = "n_" + std::to_string(i + num_inputs + 1);
                // Add inputs
                int input_index_1, input_index_2, function_type;
                sin >> input_index_1 >> input_index_2 >> function_type;
                auto input_1 = netlist->has_node("n_" + std::to_string(input_index_1));
                if (input_1 != nullptr) {
                    (input_1->num_fanout[0])++;
                    input_1->outputs[0].emplace_back(node_name);
                } else {
                    Node *node = new Node("n_" + std::to_string(input_index_1));
                    node->outputs.emplace_back(std::vector<std::string>(1, node_name));
                    node->num_fanout.emplace_back(1);
                    netlist->add_node(node);
                }
                auto input_2 = netlist->has_node("n_" + std::to_string(input_index_2));
                if (input_2 != nullptr) {
                    (input_2->num_fanout[0])++;
                    input_2->outputs[0].emplace_back(node_name);
                } else {
                    Node *node = new Node("n_" + std::to_string(input_index_2));
                    node->outputs.emplace_back(std::vector<std::string>(1, node_name));
                    node->num_fanout.emplace_back(1);
                    netlist->add_node(node);
                }
                //Add current node
                auto node = netlist->has_node(node_name);
                if (node != nullptr) {
                    node->num_fanin = num_inputs;
                    node->inputs = std::vector<std::string>{"n_" + std::to_string(input_index_1),
                                                            "n_" + std::to_string(input_index_2)};
                    node->functions = std::vector<Function>(1, Function(function_type));
                } else {
                    node = new Node(node_name, num_inputs, std::vector<unsigned int>(1, 0),
                                    std::vector<std::string>{"n_" + std::to_string(input_index_1),
                                                             "n_" + std::to_string(input_index_2)},
                                    std::vector<Function>(1, Function(function_type)), std::vector<double>{-1});
                    netlist->add_node(node);
                }
                netlist->edges.emplace_back(new Edge(netlist->has_node("n_" + std::to_string(input_index_1)), node));
                netlist->edges.emplace_back(new Edge(netlist->has_node("n_" + std::to_string(input_index_2)), node));
            }

            sin >> output_node_index;
            // Add primary outputs
            if (output_node_index == 0)
                output_node_index = num_nodes + num_inputs;
            netlist->outputs.emplace_back(netlist->has_node("n_" + std::to_string(output_node_index)));
            library[std::make_pair(truth_table, label)] = netlist;
        } else {
            std::cerr << "Parsing Fault\n";
            assert(false);
        }
    }
}